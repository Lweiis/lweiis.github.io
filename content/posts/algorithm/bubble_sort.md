---
title: 冒泡排序
date: 2023-12-18
summary: 列表循环比较交换
series:
  - 面试拾遗
  - 算法
draft: false
tags:
  - 算法
categories:
  - 算法
---
## 引言

冒泡排序是一种简单但效率较低的排序算法。  
它的基本思想是多次遍历待排序的数列，每次比较两个相邻的元素，如果它们的顺序错误就交换它们。  
通过多次遍历，将最大（或最小）的元素慢慢“浮”到数列的顶端。
### 时间复杂度

1. **最好情况：** 如果输入数组已经是有序的，冒泡排序只需进行一次遍历，时间复杂度为 O(n)。
2. **最坏情况：** 如果输入数组完全逆序，冒泡排序需要进行 n 次遍历，每次遍历比较 n-i-1 次，总的比较次数是 n*(n-1)/2，时间复杂度为 O(n^2)。
3. **平均情况：** 平均时间复杂度也为 O(n^2)，因为冒泡排序的每一轮都会比较相邻元素并进行交换，平均情况下比较次数和最坏情况相似。

### 空间复杂度

冒泡排序的空间复杂度为 O(1)，它是一个原地排序算法，不需要额外的空间存储除了原数组之外的数据结构。

## 冒泡排序的基本实现

冒泡排序的基本步骤如下：

1. 从头到尾遍历待排序数组。
2. 比较相邻元素，如果顺序错误就交换它们。
3. 重复以上步骤，直到没有需要交换的元素。

下面是一个简单的冒泡排序的实现代码：  
```Java
    // 基本冒泡排序
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    // 交换元素
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
```

## 代码优化

### 1. 优化遍历范围

由于每次遍历都会将最大（或最小）的元素移动到末尾，因此在每轮遍历后，实际上最后的元素已经是有序的，无需再次遍历。因此，我们可以优化遍历范围，减少不必要的比较。

pythonCopy code

```Java
    // 优化冒泡排序
    public static void optimizedBubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n; i++) {
            // 标志位，用于判断是否发生交换
            boolean swapped = false;
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    // 交换元素
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }
            // 没有交换，数组已有序，提前退出
            if (!swapped) {
                break;
            }
        }
    }


```

### 2. 优化逆序对的处理

如果在一轮遍历中没有发生交换，说明数组已经有序，可以提前退出循环。这样，在最好的情况下，时间复杂度可以降低到 O(n)。

## 结论

冒泡排序虽然简单，但其效率相对较低，特别是对于大规模数据。通过对基本实现的优化，我们可以在一定程度上提高其性能。然而，尽管有这些优化，冒泡排序仍然不是处理大规模数据的最佳选择。在实际应用中，更复杂的排序算法，如快速排序或归并排序，通常能够提供更好的性能。